# LIS 알고리즘
## 백준 11053번 풀이
어제 배운 LIS 알고리즘을 직접 구현해보았다. 어제 배웠던 거라 금방 구현하였다.

### 핵심 
### for루프를 0 ~ n-1까지 돌면서 dp[i] = 1로 초기화 해준다. (현재 위치 =i)
### 그리고 for루프를 한번 더 돌아 j를 0에서부터 i-1까지 순회하게 하면서, dp[i]가 dp[j] 보다 큰지 확인한다.
### 만약 크다면, dp[i]에 dp[i]와 dp[j]+1을 비교하여 더 큰 값을 할당한다.

## 백준 12015번 풀이
다른 건 없고 input 사이즈가 달랐다. 11053번은 천개 정도의 input이었는데, 12015번은 input 사이즈가 백만이었다. 따라서 O(N^2)으로는 해결이 되지 않고 O(NlogN)으로 해결해야한다는 것을 깨달았다. 
이거는 다른 사람의 블로그 풀이를 참고하여 풀었다. 생각은 기발하면서도 다시 한번 내가 따로 구현봐야겠다는 생각이 들었다.
### 핵심 아이디어는 LIS를 만들기 위해서 만드는 과정에서 LIS의 마지막 원소가 가능한 작을수록 더 긴 LIS를 생성할 수 있다는 것이다.
### 그러므로 원소가 들어올 때 만약 현재 생성된 LIS의 마지막 원소보다 작은 경우, LIS에 들어갈 위치를 이분탐색으로 찾은 후(O(logN)) 원소를 대체한다.

또한 아직 이분탐색에 대한 개념이 명확치 않아 내일은 이분탐색에 대해 문제를 풀어봐야겠다는 생각이 들었다.
참고한 블로그 사이트 url은 https://wogud6792.tistory.com/33 이다. 이게 dp와 이분탐색을 모두 구현한 것이라고 하는데, 이분탐색은 맞으나 dp인지는 명확하게 잘 모르겠다. 
이것은 최대 사이즈만 구하지 최장 증가 수열을 정확히 구해낼 수 없는 알고리즘이라고 말한다. 따라서 최장 증가 수열을 정확히 구현해낼 수 있는 알고리즘도 공부를 해야겠다.
