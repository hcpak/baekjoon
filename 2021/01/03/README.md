# 백준 알고리즘 구현 16967 2290
## 배열 복원하기 16967
이런 구현 문제 나올때마다 다른 사람들은 어떻게 효율적으로 접근할 지 궁금했다. 하지만 다른 사람들 블로그를 보니 나와 비슷하게 접근했다.
https://train-validation-test.tistory.com/entry/%EB%B0%B1%EC%A4%80-16967%EB%B2%88-Silver-III-%EB%B0%B0%EC%97%B4-%EB%B3%B5%EC%9B%90%ED%95%98%EA%B8%B0-SOLVED-BY-JAVAㅇㅇ

### 핵심 아이디어 
### 겹치지 않는 부분을 먼저 구하고, 겹치는 부분을 겹치지 않는 부분을 통해 구한다.
### 핵심 아이디어 코드
```
for(int i =0; i<h+x;i++){
    for(int j =0; j<w+y;j++){
        scanf("%d", &temp);
        // 겹치지 않는 부분
        if(i<x &&  0<=j && j <w){
            A[i][j] = temp;
        }
        // 겹치지 않는 부분
        else if(j <y && 0<= i && i <h){
            A[i][j] = temp;
        }
        // 겹치는 부분 : 겹치지 않는 부분을 통해서 구한다.
        else if( x<=i && i<h && y<=j && j <w){
            A[i][j] = temp - A[i-x][j-y];
        }
    }
}
```

## LCD 테스트 2290
이 구현 문제는 정말로 당황스러웠다. 이런 구현 문제는 거의 처음 접해보았다. 
특히 가장 어려웠던 건 0,1,2,3 순서대로 출력하는 게 아니라 0,1,2,3,4,5 -> 갔다가 다시 0,1,2,3,4,5 이런 식으로 newline을 어떻게 해야할지 고민이 많았다.
높이와 가로에 따라 구획을 나눠서 접근해야겠다는 생각이 들었다. 
이 문제를 3번 정도 틀렸는데, 테스트를 똑바로 안해서 틀렸다. 앞으로는 한번에 맞을 수 있도록 Testcase를 꼼꼼히 만들어야 겠다.
그리고 이 같은 문제들은 사람들이 어떻게 푸는 지 궁금했는데 다른 사람도 비슷하게 접근했다. 

### 핵심 아이디어
### 머리부분, 위쪽 왼쪽, 위쪽 오른쪽, 가운데부분, 아래쪽 왼쪽, 아래쪽 오른쪽, 맨 아래로 구획을 7개로 나누었다. 
### 0,1,2,3,4,5,6,7,8,9를 해당 구역에 맞게 check[구획 번호][n번째 수]로 true, false로 설정했다.
