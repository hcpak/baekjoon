# 백준 DP 구현
## 가장 긴 증가하는 부분 수열 11053
### 핵심 아이디어: O(N^2)으로 탐색하면서 DP 짰다. 
O(NlogN)으로 푸는 방법을 익혀야 겠다.

## 퇴사 2 15486
### 핵심 아이디어: dp[i] = max(dp[i], dp[i-1])을 먼저 한 후에 Ti 값에 따른 갱신을 해야한다. 
```
for(int i = 0; i<n;i++){
    if(i != 0){
        dp[i] = max(dp[i], dp[i-1]);
    }
    if(i + T[i] <= n){
        dp[i + T[i]] = max(dp[i + T[i]],dp[i]+P[i]);
        answer =max(answer,dp[i+T[i]]);
    }
}
```

## 큰수 10757
### 핵심 아이디어: 결과값이 역순으로 저장할 수 밖에 없는데 이를 stack으로 해결했다.
이 문제 상당히 까다로웠다. string으로 역순으로 저장해서 구하는 방법도 있었다.

## 피보나치 수 4
### 핵심 아이디어: 이 문제는 dp가 중요하다기 보단 unsigned long long를 벗어나는 숫자를 어떻게 표현하느냐가 중요했다.
이 문제 때문에 큰수를 풀게 되었다.